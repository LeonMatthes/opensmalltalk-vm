# Plugin Creation

Plugins in Squeak are native binaries that inter-operate with the VM.

They can be categorized as either:
- internal (static libraries that are linked directly into the VM)
- external (dynamic libraries that are loaded on demand)

To understand how Plugins are built, have a read through the [Build System page](../build-system.md).

After you have [set up your VMMaker image](../vmmaker-image-creation.md), you can start creating a plugin from within Squeak.

Most plugins are written in [Slang](./Slang.md) and are therefore developed from within Smalltalk.

## Creating your own plugin
To get started, create a subclass of [InterpreterPlugin](squeak://InterpreterPlugin).

Then you can get started writing your own Slang code.  
For example, add a class `MyPlugin`  as follows:
``` smalltalk
SmartSyntaxInterpreterPlugin subclass: #MyPlugin
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Playground'
```
with one member function:
``` smalltalk
primitiveSeven
	
	"#primitive: Marks this method to be accessible as a primitive"
	self primitive: 'primitiveSeven'.
	^ 3 + 4
```
See the aforementioned [Slang page](./Slang.md) for instructions of how to transpile your Slang sources to C.

If you take a look at the `HowToBuild` file in the `building` folder for your operating system it should contain the information of how to add your Plugin to your build system.
Typically this simply means adding your plugin to a `plugins.ext` or `plugins.int` file, depending on whether you want an internal or external plugin.

After rebuilding the vm, you should then have a `MyPlugin` shared library somewhere (e.g. `MyPlugin.so`, `MyPlugin.dll`, etc.).

You can then define a function in another class like this:
```
seven

	<primitive: 'primitiveSeven' module: 'MyPlugin'>
	^ self reportPrimitiveFailure
```

## Linking to external C code
Thus far, our plugin is self-contained and doesn't have any dependencies to anything other than Slang code.

Often times however, you will want to link to other C dependencies.
For this to work, you can simply call a function that you'll later define in C (or that already exists in C) with the appropriate arguments.

Take a look at the [ProcessorSimulatorPlugin>>#primitiveNewCPU](squeak://ProcessorSimulatorPlugin>>#primitiveNewCPU) for an example.
In this function, `newCPU` is called, even though that function is not generated by Slang.
The simulator plugins, like the [BochsX64Plugin](squeak://BochsX64Plugin) define these functions in C.

Any C file defined in `platforms/Cross/plugins/<MyPluginName>` will be compiled and linked into your plugin. See the `platforms/Cross/plugins/BochsX64Plugin/sqBochsX64Plugin.cpp` file for an example.
There you can define any code you need to wrap your C dependency to create an API that can be called from Slang.

The `platforms/<YourOS>/plugins/<MyPluginName>` folder can then be used to define special steps to perform during platform compilation.
For example `platforms/unix/plugins/BochsX64Plugin` folder contains files that are automatically included when recreating the configure script.
In the case of unix, this will contain a Makefile, as well as an `.m4` script.
See the [Build System](../build-system.md) for more information of how the build system works.
I also recommend browsing the existing plugins code in the repository.